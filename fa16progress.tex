\documentclass[11pt]{article}
% decent example of doing mathematics and proofs in LaTeX.
% An Incredible degree of information can be found at
% http://en.wikibooks.org/wiki/LaTeX/Mathematics

% Use wide margins, but not quite so wide as fullpage.sty
\marginparwidth0.5in 
\oddsidemargin0.25in 
\evensidemargin0.25in 
\marginparsep0.25in
\topmargin 0.25in 
\textwidth 6in \textheight 8 in
% That's about enough definitions

\usepackage{amsmath}
\usepackage{upgreek}
\usepackage{enumerate}
\usepackage{graphicx}
\usepackage{enumitem}
\usepackage{amssymb}
\usepackage{listings}
\usepackage{mathtools}
\usepackage{array}
\usepackage{verbatim}
\usepackage{multirow,bigdelim}
\usepackage{stmaryrd}

\newcommand*{\br}[1]{\llbracket{#1}\rrbracket}
\newcommand\myeq{\stackrel{\mathclap{\normalfont\mbox{def}}}{=}}

\begin{document}
\title{Linear Lambda Calculus Compiler: Fall '16}
\author{Anna Yesypenko, supervised by Professor Nate Foster}
\maketitle

\section*{Overview}
Before we begin, a few quick reminders on the compiler. We compile the source language, linear lambda calculus programs $e$
\begin{align*}
    b\ &::=\ +\ |\ -\ |\ /\ |\ *\\
    e\ &::=\ n\ |\ x\ |\ e_1\ b\ e_2\ |\ \text{let}\ x\ =\ e_1\ \text{in}\ e_2\\
    &|\ \lambda\ x.\ e\ |\ e_1\ e_2
\end{align*}
to the target language, stack machine programs $\rho$
\begin{align*}
    \rho &::=\ instr\ \text{list}\\
    instr\ &::=\ \text {Push}\ n\ |\ \text {Add}\ |\ \text {Subt}\ |\ \text {Mult}\ |\ \text {Div}\\
    & |\ \text{Roll}\ n\ |\ \text {Unroll}\ n\ |\ \text{Form\_Closure}\ (n_v, n_{\rho})\ |\ \text{Apply}
\end{align*}
which operate on a stack $\sigma$
\begin{align*}
    v\ &::=\ \text {Int}\ n\ |\ \text {CL}\ (n, \rho) \\
    \sigma &::=\ v\ \text{list}
\end{align*}
Instructions execute as defined in the documentation. Here, we highlight a few that we will adjust later. The execution of instructions is defined on the tuple $(\rho, \sigma, \sigma_h \in \text{int list}, \rho_h)$, where $\rho_h$ is a program history tape that records instructions executed. Each instruction is reversible.
\begin{gather*}
    (\text{Form\_Closure}\ (n_i, n_v)::\hat{\rho}::\rho, \hat{\sigma}::\sigma, \sigma_h, \rho_h), \text{where $|\hat{\rho}| = n_i$ and $|\hat{\sigma}| = n\_v$}\\
    \Longleftrightarrow (\text{CL}\ (\hat{\rho}, \hat{\sigma}) :: \rho, \sigma, \sigma_h, \text{Form\_Closure}\ (n_o, n_v)::\rho_h)\\ \\
    (\text{Apply}::\rho, v::\text{CL}\ (\hat{\rho}, \hat{\sigma})::\sigma, \sigma, \sigma_h, \rho_h) \\
    \Longleftrightarrow (\hat{\rho}\ @\ \rho, \hat{\sigma}\ @\ \sigma, |\hat{\rho}|::|\hat{\sigma}|::\sigma_h, \text{Apply}::\rho_h)
\end{gather*}
We have been attempting to reverse apply without adding information to $\sigma_h$. Suppose $l\ ::=$ (lam $x$. $e$) corresponds to the stack value $c\ ::=$ $\text{CL}(\hat{\sigma}, \hat{\rho})$, where $\hat{\sigma}$ are the stack values corresponding to free variables of $l$ and $\hat{\rho}$ is the compilation of the function body $e$. We noted that if $l$ is a well-formed closure and $\hat{\rho}$ has the grow-shrink property (see documentation for definitions), then we need not store $|\hat{\rho}|$
to recover the closure $c$ following an Apply instruction.

\textbf{Objective CL:} Produce programs $\rho$ such that all stack closures CL$(\hat{\sigma}, \hat{\rho})$ produced during the execution of $\rho$ on stack $\sigma$ have $|\hat{\rho}| = c$ for some constant $c$, in addition to closures being well-formed and $\hat{\rho}$ obeying the grow-shrink property.

\section*{Motivating Example:}
\begin{lstlisting}[mathescape = true]
let add = $\lambda$ x$.\ \lambda$ y.x + y in
let g   = $\lambda$ f.f 1 in
g (add 2)
\end{lstlisting}

The example above is lambda-lifted. That is, the top-level functions add and g are closed. Therefore, all the top-level functions can be represented as stack closures CL$(\hat{\sigma}, \hat{\rho})$ with $|\hat{\sigma}| = 0$. However, the partially applied function $(add 2)$ has free variable `x'. Representing such a lambda on the stack would require a closure with $|\hat{\sigma}| = 1$. 

Therefore, lambda lifting does not produce programs that satisfy Objective CL\@.

\section*{Defunctionalization:}

Given a lambda-calculus program $p$, defunctionalization produces a first-order language. That is, functions are no longer considered to be values. Instead, $l\ ::=\ (\lambda x.\ e)$ is represented as $C(v_1, \dots, v_n)$, where $C$ uniquely identifies the function, and $v_1, \dots, v_n$ are the values of the variables $x_1, \dots, x_n$ which are free in $l$.

We define the translation from lambda-calculus program to first-order program.
\begin{align*}
    \br{x} &= x\\
    \br{\lambda x.\ e} &= C_{\lambda x.\ e} (x_1, \dots, x_n),\ \text{where $x_1, \dots, x_n$ are free in $\lambda x.\ e$}\\
    \br{e_1\ b\ e_2} &= \br{e_1}\ b\ \br{e_2}\\
    \br{\text{let}\ x = e_1\ \text{in}\ e_2} &= \br{(\lambda x.\ e_2)\ e_1}\\
    \br{e_1\ e_2} &= \text{apply}(\br{e_1}, \br{e_2})
\end{align*}

Thus a lambda calculus program $p$ is translated to a first-order program as such:
\begin{lstlisting}[mathescape = true]
let rec apply (f, arg) = 
    match f with
    | C$_{\lambda x.\ e}$ -> let x = arg in $\br{e}$
    | $\dots$ in
    $\br{p}$
\end{lstlisting}

We defunctionalize the example presented earlier $$\br{(\lambda\ add.\ (\lambda\ g.\ g\ (add\ 2))\ (\lambda\ f.\ f\ 1)) (\lambda\ x.\ (\lambda\ y.\ x + y))}.$$
\begin{lstlisting}[mathescape = true]
let rec apply (f, arg) = 
    match f with
    | Cletadd     () -> let add = arg in apply (Cletg (add), Cg ())
    | Cletg    (add) -> let g   = arg in apply (g, apply (add, 2))
    | Cg          () -> let f   = arg in apply (f, 1)
    | Cadd        () -> let x   = arg in Caddacc (x)
    | Caddacc    (x) -> let y   = arg in x + y
    apply (Cletadd (), Cadd ())
\end{lstlisting}

The above program evaluates as follows:
\begin{lstlisting}
apply (Cletadd      (),            Cadd ())
apply (Cletg (Cadd ()),              Cg ())
apply (Cg           (), apply (Cadd (), 2))
apply (Cg           (),        Caddacc (2))
apply (Caddacc     (2),                  1)
2 + 1
\end{lstlisting}

\section*{Executing Defunctionalized Programs on Stack Machine:}

We introduce the idea of a function stack. First let's adjust our definitions for machine programs and stacks.
\begin{align*}
    \rho &::=\ instr\ \text{list}\\
    instr\ &::=\ \dots\ |\ \text{Form\_Closure}\ (n_{\rho})\ |\ \text{Apply}\\
    & |\ \text{Compose\_Tuple}\ n\ |\ \text{Decompose\_Tuple}\ n\\
    & |\ \text{Load}\ |\ \text{Save @fun}\ |\ \text{Push @fun}\\
    cl &::=\ \text{CL}\ (\text{@fun}, \rho)\\
    \sigma_f &::=\ cl\ \text{list}\\
    v\ &::=\ \text {Int}\ n\ |\ \text{Tuple}\ (v_1, \dots, v_n)\ |\ \text{@fun}\ (v_1, \dots, v_n) |\ CL (\rho) \\
    \sigma &::=\ v\ \text{list}
\end{align*}

These definitions operate on the tuple $(\rho, \sigma, \sigma_f, \sigma_h \in \text{int list}, \rho_h)$. The instructions omitted operate as they are defined previously in the documentation (without modifying $\sigma_f$).  

\begin{gather*}
    (\text{Load}::\rho, \text{@fun}(v_1, \dots, v_n)::\sigma, \text{CL}(\text{@fun}, \hat{\rho})::\sigma_f, \sigma_h, \rho_h)\\
    \Longleftrightarrow (\rho, \text{CL}(\hat{\rho}):: \text{Tuple}(v_1, \dots, v_n)::\sigma, \sigma_f, \sigma_h, \text{Load}::\rho_h)\\ \\
    (\text{Save @fun}::\rho, \text{CL}(\hat{\rho})::\sigma, \sigma_f, \sigma_h, \rho_h)\\
    \Longleftrightarrow (\rho, \sigma, \text{CL}(\text{@fun}, \hat{\rho})::\sigma_f, \sigma_h, \text{Save @fun}::\rho_h)\\ \\
    (\text{Push @fun}::\rho, \text{Tuple}(v_1, \dots, v_n)::\sigma, \sigma_f, \sigma_h, \rho_h)\\
    \Longleftrightarrow (\rho, \text{@fun}(v_1, \dots, v_n)::\sigma, \sigma_f, \sigma_h, \text{Push @fun}::\rho_h)\\ \\
    (\text{Form\_Closure}\ (n_{\hat{\rho}})::\hat{\rho}::\rho, \sigma, \sigma_f, \sigma_h, \rho_h), \text{where $|\hat{\rho}| = n_{\hat{\rho}}$}\\
    \Longleftrightarrow (\text{CL}\ (\hat{\rho}) :: \rho, \sigma, \sigma_f, \sigma_h, \text{Form\_Closure}\ (n_{\hat{\rho}})::\rho_h)\\ \\
    (\text{Apply}::\rho, \text{CL}\ (\hat{\rho}):: \text{Tuple}(v_1, \dots, v_n)::v::\sigma, \sigma_f, \sigma_h, \rho_h) \\
    \Longleftrightarrow (\hat{\rho}\ @\ \rho, \text{Tuple}(v_1, \dots, v_n)::v::\sigma, \sigma_f, |\hat{\rho}|::\sigma_h, \text{Apply}::\rho_h)\\
    \Longrightarrow^* (\rho, result::\sigma, \dots)\\ \\
    (\text{Compose\_Tuple}\ n::\rho, v_1:: \dots:: v_n::\sigma, \sigma_f, \sigma_h, \rho_h)\\
    \Longleftrightarrow (\rho, \text{Tuple}(v_1, \dots, v_n)::\sigma, \sigma_f, \sigma_h, \text{Compose\_Tuple}\ n::\rho_h)\\ \\
    (\text{Decompose\_Tuple}\ n::\rho, \text{Tuple}(v_1, \dots, v_n)::\sigma, \sigma_f, \sigma_h, \rho_h)\\
    \Longleftrightarrow (\rho, v_1::\dots::v_n::\sigma, \sigma_f, \sigma_h, \text{Decompose\_Tuple}\ n::\rho_h)\\ \\
\end{gather*}

For the tuple operations, $n \ge 0$, and for $n = 0$, the tuple formed is simply (). 
The functions annotations @fun appear for clarity. The tags can be removed from the stack machine language. We have omitted an instruction RollF from above that operates on $\sigma_f$ in the same manner that Roll operates on $\sigma$.

Machine instructions corresponding to a defunctionalized program $e_{df}$ begins with a series of Form\_Closure and Save instructions that populate $\sigma_f$. 

\break{}

Consider the defunctionalization of a simple example $$\br{\text{let}\ a = 10\ \text{in}\ (\lambda x.x+a)\ 5} = \br{(\lambda a.(\lambda x.x+a)\ 5)\ 10}.$$

\begin{lstlisting}
let rec apply (f, arg) = 
    match f with 
    | C1  () -> let a = arg in apply (C2 (a), 5)
    | C2 (a) -> let x = arg in x + a
apply (C1 (), 10)
\end{lstlisting}

Here are the machine instructions corresponding to this program:\\
Form\_Closure (7);\ \textit{closure for C1}\\
Decompose\_Tuple 0; Push 5; Unroll 2;\\
Compose\_Tuple 1; Push @2;\\
Load; Apply;\\
\textbf{Save @1};\\
Form\_Closure (2);\ \textit{closure for C2}\\
Decompose\_Tuple 1; Add;\\
\textbf{Save @2};\\
Push 10; Compose\_Tuple 0; Push @1\\
Load; Apply\\

Now we execute the above instructions and provide snapshots of the stack $(top)[\ ](bottom)$. Assume we have already saved @1 and @2 to $\sigma_f$.\\
Push 10; Compose\_Tuple 0; Push @1;\\
\textit{Stack looks like [@1(), 10]}\\
Load; Apply;\\
\textit{Stack looks like [(), 10]}\\
Decompose\_Tuple 0; Push 5; Unroll 2;\\
Compose\_Tuple 1; Push @2;\\
\textit{Stack looks like [@2(10), 5]}\\
Load; Apply;\\
\textit{Stack looks like [(10), 5]}\\
Decompose\_Tuple 1; Add\\
\textit{Stack looks like [15]}

\break{}


\section*{Reversibility of Apply}

Define $\vec{\rho} = (\rho, \hat{\rho})$ and $\vec{\sigma} = (\sigma, \text{Tuple}(v_1, \dots, v_n), \arg)$.
\begin{align*}
\textbf{Well-Formed Closure Property}: \\
    \text{wf} (\vec{\rho}, \vec{\sigma})\ &\myeq\ (\text{Apply}::\rho, \text{CL} (\hat{\rho})::\text{Tuple} (v_1, \dots, v_n)::\arg::\sigma, \dots)\\
    &\Longrightarrow (\hat{\rho}\ @\ \rho, \text{Tuple}(v_1, \dots, v_n)::\arg::\sigma, \dots) \Longrightarrow^* (\rho, result::\sigma, \dots)
\end{align*}

Take the subset of machine instructions that can appear in the body of a closure (thus, exclude Form\_Closure and Save). We classify these instructions into those which grow the stack ($i_g$) and those which shrink or do not change the size of the stack ($i_s$).

\begin{align*}
    i_g ::=&\ \text{Push}\ n\ |\ \text{Decompose\_Tuple}\ (n > 1)\ |\ \text{Compose\_Tuple}\ 0 \\
    \rho_g ::=&\ i_g\ \text{list}\\
    i_s ::=&\ \text {Add}\ |\ \text {Subt}\ |\ \text {Mult}\ |\ \text {Div}\\
    & |\ \text{Roll}\ n\ |\ \text {Unroll}\ n\ |\ \text{Apply}\\
    & |\ \text{Push @fun}\ |\ \text {Load}\ n\ |\ \text{Compose\_Tuple}\ (n > 0) |\ \text{Decompose\_Tuple} (n \le 1)\\
    \rho_s ::=&\ i_s\ \text{list}
\end{align*}

Let us define the following property.
\begin{align*}
    \textbf{Grow-Shrink Property}:\\
    \text{gs}\ (\rho\ \text{where}\ |\rho| > 0)\ \myeq\ \exists \rho_g,\ \rho_s.\ \rho = \rho_g\ @\ \rho_s
\end{align*}

The Apply instruction may be injective because of the linear constraints in our language. Recall that to reverse Apply, we must split the program such that we restore the original closure. We define this split as follows.
\begin{align*}
    \text{splits}\ (\vec{\rho},\vec{\sigma})\ \myeq\ \rho' = \hat{\rho}\ @\ \rho\ \wedge : \ \texttt{wf}\ (\vec{\rho}, \vec{\sigma})
\end{align*}
If we could prove the following proposition, then Apply would be injective.
\begin{align*}
    \text{InjApply}: \quad \forall \rho', \sigma.\ \exists\ \vec{\rho_a}.\ \text{splits}\ (\vec{\rho_a}, \sigma) \wedge \exists\ \vec{\rho_b}.\ \text{splits}\ (\vec{\rho_b}, \sigma) \Longrightarrow \vec{\rho_a} = \vec{\rho_b}
\end{align*}

A further aim is to prove that InjApply holds so long as the closure we are trying to recover is of the form $cl\ ::=\ \text{CL}(\hat{\rho})$ where gs ($\hat{\rho})$ and $cl$ is well-formed.
\end{document}
